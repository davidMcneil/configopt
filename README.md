# Unified, Dynamic Rust Application Configuration

This repo explores unified, dynamic application configuration in Rust.

Ok, what does "unified, dynamic application configuration" mean? I don't really know, but the features I want are:

- the ability to configure the application from the command line.
- the ability to configure the application from a config file with support for a variety of formats.
- to make it simple to configure the application from potentially any source. For example, an HTTP request.
- to configure parts of the application from a composite of sources with a defined order of precedence. This is what I mean by _unified_. For example,
  1. Command line argument
  2. Environment variable
  3. Config file
- a single source of truth for the application's configuration when the application is running.
- to make it simple to _dynamically_ update the configuration's single source of truth while the application is running.
- the ability to write out the application's current configuration in a format that can be ingested by another instance of the application.
- to write almost zero code. All this functionality should be generated by macros.

The [`clap`](https://github.com/clap-rs/clap), [`structopt`](https://github.com/TeXitoi/structopt), and [`serde`](https://github.com/serde-rs/serde) crates get us most of the way there. We are going to explore the little bit of boilerplate needed to make all these features come together and a macro that can make the boilerplate go away.

**Note**: This uses `clap v3` and `clap_derive` which replaces `structopt`. Both of these are still in beta.

## Make the Config De/Serializable

`serde` makes the [code](0_serde_config/src/main.rs) trivial.

## Partial Configuration

We are going to add a `PartialConfig` struct to the [code](1_partial_config/src/main.rs). This allows patching part of the configuration.

If all of our arguments have a default value, this is actually all we need to meet all of our objectives. To go over the steps again:

1. Define our configuration struct
2. Create a struct for patching parts of the configuration (`PartialConfig`). This could be automated with a macro.
3. Create our config by parsing values from the command line
4. Create a partial config from a config file (or any other source)
5. Patch the config file with the partial config
6. Wrap the config in a singleton like [state::Storage](https://sergio.bz/rustdocs/state/struct.Storage.html) to have a single source of truth for the app configuration that is safe to update on the fly

This only works because all arguments have a default value so we can always construct a valid config simply by parsing the command line arguments, but what if all the arguments do not have default values? That is what we are going to explore next.

## Unified Config no Macro

One way to frame what we want to do is: if the argument did not occur on the command line, make the default value of the argument the value from a partial config. Let's look at the [code](2_unified_config_no_macro/src/main.rs) to do this.

Let's run a few commands to confirm the behavior is what we want. The "config file" for these commands look like `{"foo": 5, "bar": "default value from config"}`.

    > cargo run -- # This outputs the config from the "config file"
    > cargo run -- -f 27 -b test # This overrides values from the "config file" with values from the command line
    > cargo run -- -f 27 # This only overrides the foo value
    > cargo run -- -h # In the help message, we can see that the defaults are set to the values from the "config file"

## Unified Config with Macro

This should have the exact same behavior as the previous example, but if you look at the [code](3_unified_config_with_macro/src/main.rs) all the boilerplate is gone. It is replaced by the macro `ParseWithDefaults` defined [here](parse_with_defaults_derive/src/lib.rs). This macro is totally a proof of concept. It does not handle any edge case and is very rough, but it proves that such a macro is possible.
